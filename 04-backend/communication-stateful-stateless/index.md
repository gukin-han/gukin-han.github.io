# 상태(Stateful) vs 무상태(Stateless) — 실무 엔지니어를 위한 관점

> **핵심 메시지**
> “정의(Definition)에 집착하지 말고, **부작용(사이드 이펙트)** 과 **의존성**이 시스템에 끼치는 영향을 이해하라.”

---

## 1. 왜 ‘상태’ 이야기를 꺼내는가?

* **엔지니어에게 중요한 것은 결과적 부작용**

  * 시스템이 *정상* 동작하려면 어떤 정보가 반드시 살아 있어야 하는가?
  * 그 정보가 사라졌을 때 *어떤* 서비스가 멈추는가?
* 정의 싸움은 **철학적 논쟁**일 뿐 실무 가치가 낮다.

  * 변수 하나만 있어도 “state”는 존재한다.
  * *의존* 하느냐가 관건 → “존재 여부”보다 “필수 여부”가 판단 기준.

---

## 2. 백엔드 애플리케이션 관점

### 2.1 상태 있는(Stateful) 백엔드

| 특징                      | 설명                              |
| ----------------------- | ------------------------------- |
| **메모리 안에 클라이언트별 정보 보관** | 예: 세션 객체, 게임 모드 진행 상황           |
| **그 정보에 *의존***          | 사라지면 기능이 즉시 깨짐                  |
| **재시작 테스트 실패**          | 백엔드 프로세스를 재시작하면 기존 클라이언트 흐름이 중단 |

#### 💡 예시: 메모리 세션 로그인

1. `/login` 요청 → DB 검증 후 `sessionId = S1` 생성
2. 백엔드 *메모리*에 S1 저장, 쿠키로 S1 반환
3. `/profile` 요청 → 쿠키 S1을 메모리에서 조회
4. **문제점**

   * 서버 재시작·다중 노드 로드 밸런싱 시 S1 미존재 → 다시 로그인
   * 로컬 캐시 성능은 좋지만 *스티키 세션* 필요

---

### 2.2 무상태(Stateless) 백엔드

| 특징                   | 설명                                |
| -------------------- | --------------------------------- |
| **애플리케이션 자체에 상태 없음** | 재시작해도 내부 메모리·디스크 의존 X             |
| **외부 저장소를 써도 OK**    | DB·캐시·로그 등 *다른 컴포넌트* 책임           |
| **재시작 테스트 성공**       | idle 시 컨테이너를 내렸다 올려도 클라이언트 플로우 유지 |

#### 💡 예시: DB 기반 세션

1. `/login` → S1 생성 **+ DB에 저장**
2. 쿠키 S1만 전달, 서버는 매 요청마다 DB로 “S1 유효?” 확인
3. 어떤 인스턴스가 응답하든 동일 결과
4. 단점: 매 요청 DB 왕복 비용, DB 장애 시 시스템 전체 중단

---

### 2.3 ‘무상태’가 만능은 아니다

* 뱃지가 아닌 **트레이드오프**

  * *캐시 미스 증가* vs *확장성·장애 허용도*
* 상황별로 **부분적 상태**를 두기도 함

  * 실시간 게임 매치메이킹처럼 초저지연이 필수면 로컬 메모리 캐시 + 스티키 세션 채택

---

## 3. 프로토콜 관점

### 3.1 상태 있는 프로토콜

| 프로토콜     | 저장되는 상태                                                   |
| -------- | --------------------------------------------------------- |
| **TCP**  | 시퀀스·ACK 번호, 윈도 크기, 혼잡 제어 윈도우, 상태 머신(CLOSED/ESTABLISHED 등) |
| **QUIC** | Connection ID·스트림 ID·플로우 제어 정보 (UDP 위에서 자체 구현)            |

### 3.2 무상태 프로토콜

| 프로토콜             | 특성                                                            |
| ---------------- | ------------------------------------------------------------- |
| **UDP**          | 연결·재전송 없음, 메시지 단위 전송                                          |
| **DNS** (UDP 기반) | *Query ID*를 포함해 각 패킷이 자체적으로 매칭 정보를 휴대                         |
| **HTTP**         | 명세상 *Stateless* (요청마다 “완전한 문맥” 전달) <br>↳ 쿠키·헤더로 클라이언트가 상태를 운반 |

### 3.3 위아래 층이 뒤섞인 사례

* **HTTP(Stateless)** over **TCP(Stateful)**

  * TCP 끊기면 그냥 새 커넥션 생성 → HTTP 자체 로직엔 영향 없음
* **QUIC(Stateful)** over **UDP(Stateless)**

  * 연결 정보가 매 패킷에 포함되므로 “Stateless UDP 위 State 관리” 구현

---

## 4. 완전한 ‘시스템’ 레벨에서의 무상태는 드물다

* 입력이 모든 문맥을 포함해야 함

  * 예: “이 숫자가 소수인가?” 연산 서비스
* **JWT**

  * 서명된 토큰 하나에 인증·권한 정보를 모두 담음
  * 서버 저장소 없이도 검증 가능 → 완전 무상태 인증
  * **단점**: 토큰 탈취 시 실시간 폐기가 어려움 → *Refresh Token*·짧은 만료·TLS로 보완

---

## 5. 실무 체크리스트

### 5.1 내 백엔드는 무상태인가?

1. **재시작 테스트**

   * 요청이 없는 타이밍에 컨테이너를 kill → 재접속 시 정상 동작?
2. **로컬 캐시 사용 여부**

   * 캐시 미스해도 기능이 깨지지 않는가?
3. **로드 밸런서 설정**

   * 스티키 세션이 없으면 클라이언트 경험이 변하지 않는가?

### 5.2 상태 설계 시 주의할 점

* **스티키 세션**: 짧은 캐시를 위해 로컬 상태를 둘 때는 LB Affinity 고려
* **세션 저장 위치**: 메모리 ↔ Redis ↔ DB (속도·영속성·운영 난이도 트레이드오프)
* **장애 전파 범위**: 상태 저장소(예: DB) 장애가 서비스 전체를 마비시키지 않도록 **Circuit Breaker**·읽기 전용 모드 등 대비

---

## 6. 결론 — 정의보다 ‘효과’를 보라

* **상태 의존성**을 최소화하면 확장성과 장애 허용도가 커진다.
* 그러나 **성능·복잡도·개발 속도**를 맞바꾸는 선택지임을 잊지 말 것.
* 궁극적으로 중요한 질문:

  1. “이 정보가 사라져도 서비스가 버틸 수 있는가?”
  2. “버틸 수 없다면, 나는 그 위험을 감수할 만한 충분한 이점을 얻고 있는가?”

> **아직 모든 문제가 해결된 것은 아니다.**
> 새로운 요구가 나오면 정의·패턴·도구는 다시 변한다.
> 오늘의 ‘정답’도 내일이면 *yet another trade-off*가 될 수 있다.
