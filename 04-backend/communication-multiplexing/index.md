# 멀티플렉싱(Multiplexing) vs 디멀티플렉싱(De-multiplexing)

> 여러 개의 독립적인 신호(요청·연결·경로)를 **하나의 파이프**로 합치는 것이 멀티플렉싱,
> 하나의 파이프에 섞여 들어온 신호를 **다시 여러 갈래**로 분리해 내보내는 것이 디멀티플렉싱.

---

## 1. 핵심 개념

### 1.1 멀티플렉싱이란?

* **다중 입력 → 단일 출력**

  * 예) 3 개의 TCP 연결(또는 사용자 요청)을 1 개의 TCP 연결로 합침
* **장점**

  * 연결 수 감소 → 커널·네트워크 레벨 오버헤드 절감
  * 여러 스트림을 “한 통로”로 보내므로 **헤드-오브-라인(Head-of-Line) 블로킹** 완화(HTTP/2 이상)
* **단점**

  * 한 연결에 모든 스트림이 몰리면 **혼합 파싱 비용** 증가
    (서버가 하나의 소켓에서 프레임을 분류·조립해야 함)

### 1.2 디멀티플렉싱이란?

* **단일 입력 → 다중 출력**

  * 예) 프록시가 받아 둔 1 개의 HTTP/2 연결을 백엔드의 여러 HTTP/1.1 연결로 분리
* **장점**

  * 각 요청이 **독립적인 흐름 제어·혼잡 제어**를 누려 서로 영향 최소화
* **단점**

  * 연결 수 증가 → 리소스(파일 디스크립터, TLS 핸드셰이크 등) 부담

---

## 2. HTTP 계층에서의 적용

### 2.1 브라우저 ↔ 서버: HTTP/1.1

| 특징           | 설명                           |
| ------------ | ---------------------------- |
| **동시 연결 상한** | 크롬 기준 **호스트당 6개** TCP 연결     |
| **파이프라이닝**   | 기본 비활성화 → 한 연결 안에서도 순차 처리    |
| **결과**       | 요청이 6개를 초과하면 대기(Blocking) 발생 |

#### 📌 실습 데모

1. Long-Polling API를 열어 6 개 요청을 동시에 보냄
2. 모든 요청이 응답 대기 상태이면 **새 요청이 전송조차 되지 않음**
3. 일부 응답이 돌아오자마자 큐에 있던 요청들이 순차적으로 송신

### 2.2 브라우저 ↔ 서버: HTTP/2

* **연결 수: 1개**

  * 단일 TCP 소켓 위에서 **다중 스트림**(Stream ID) 동시 전송
* **멀티플렉싱 효과**

  * 브라우저 한도(6개) 제한 해소
  * 그러나 서버는 한 소켓에서 다수 스트림을 디멀티플렉싱해야 하므로 CPU 부담 ↑

### 2.3 프록시가 존재할 때

#### (1) **프론트 HTTP/1.1 → 백엔드 HTTP/2**

> Envoy·Nginx 등 리버스 프록시
> 클라이언트 입장에선 3개의 TCP, 프록시는 백엔드로 1개의 HTTP/2

* **동작**: 프록시가 **멀티플렉싱** 수행
* **이득**: 백엔드 연결 수↓, 핸드셰이크 비용↓
* **주의**: 백엔드 HTTP/2 서버 부하는 ↑

#### (2) **프론트 HTTP/2 → 백엔드 HTTP/1.1**

> 프록시가 스트림을 분해해 여러 백엔드 연결로 전달

* **동작**: 프록시가 **디멀티플렉싱** 수행
* **이득**: 각 연결이 독립적 → 지연이 서로 전파되지 않음

---

## 3. DB Connection Pool = 멀티플렉싱의 또 다른 얼굴

### 3.1 원리

1. 애플리케이션 시작 시 **N개**의 DB 연결을 미리 생성(“Warm”)
2. 요청이 들어오면 **빈 커넥션**을 할당해 쿼리 실행
3. 쿼리 완료 후 커넥션을 풀에 반환

### 3.2 장·단점

* **장점**

  * 매 요청마다 핸드셰이크/인증 → 생략
  * 고정된 연결 수로 OS 리소스 예측 가능
* **단점**

  * 풀 전체가 Busy일 때 **대기 큐** 발생 → 애플리케이션 지연
  * 한 커넥션에서 다중 쿼리 병렬 전송이 어려움

    * 응답-ID 매칭 불가 → Postgres 14+ “Pipeline Mode”가 이를 부분 해결

### 3.3 예시

* Django(전통적 버전)는 **스레드당 1커넥션**만 사용하는 한계
* 풀 크기=4인 경우

  * 4개의 SQL이 동시에 실행 중이면 5번째 요청은 **블록**
  * 하나 완료되어야 다음 쿼리가 전송 → “디멀티플렉싱 대기열” 효과

---

## 4. 멀티패스 TCP & Quick(HTTP/3) - 확장 개념

| 기술                | 멀티플렉싱 포인트            | 특징                         |
| ----------------- | -------------------- | -------------------------- |
| **Multipath TCP** | 여러 물리 경로 ↔ 논리적 단일 연결 | 모바일(5G+Wi-Fi) 핸드오버에 강점     |
| **QUIC / HTTP-3** | UDP 기반 다중 스트림        | TCP HOL 블로킹 제거 + 0-RTT 재연결 |

---

## 5. 실무 체크리스트

### 5.1 언제 멀티플렉싱을 쓰나?

* HTTP/2·gRPC 같은 **스트림 다중화 프로토콜** 사용 시
* 백엔드-프록시 간 **연결 수를 줄여야** 할 때
* **모바일 네트워크**에서 핸드셰이크 비용 최소화가 중요할 때

### 5.2 언제 디멀티플렉싱(풀링)을 쓰나?

* DB 쿼리, 메시지 큐 등 **상태 기반 세션**이 필요한 경우
* 대용량 트래픽에서 **개별 흐름의 QoS**를 보장하고 싶을 때
* 각 요청의 지연이 서로 영향을 주면 안 될 때

### 5.3 성능 진단 포인트

* **CPU 스핀**: HTTP/2 서버가 프레임 파싱으로 과점유?
* **커넥션 수**: 브라우저 6-커넥션 한계에 걸리는지 확인 (Chrome DevTools → Waterfall)
* **DB 풀 대기열**: 풀 사이즈·대기 시간 모니터링 (Prometheus, pgBouncer stats 등)

---

## 6. 결론

* **멀티플렉싱 ↔ 디멀티플렉싱**은 **연결 수, 리소스, 지연** 사이의 트레이드오프를 조정하는 도구
* 동일 기술 스택에서도 **프론트·백·DB** 레이어마다 적용 방식이 달라짐
* 실무에서는 **네트워크·OS·애플리케이션·DB** 전 구간을 관찰하며

  * 병목 구간에 맞춰 **멀티플렉싱 전략**을 선택·조정해야 한다.
